<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Interaktives RSA-Tool f√ºr Lernzwecke</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1, h2 { text-align: center; margin-bottom: 20px; }
        h1 { font-size: 2.5em; }
        h2 { font-size: 1.8em; color: #ffd700; border-bottom: 2px solid #ffd700; padding-bottom: 10px; margin-top: 40px;}

        .section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px; border-radius: 15px; margin-bottom: 30px;
        }
        
        .input-row, .output-row {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
            justify-content: center;
        }
        
        .input-group, .output-group {
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
            background: rgba(0,0,0,0.2);
            padding: 10px 15px;
            border-radius: 10px;
        }
        
        .output-group { background: rgba(0,0,0,0.4); }
        .output-value { font-weight: bold; font-size: 1.2em; color: #4ecdc4; }
        
        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        label { font-weight: bold; font-size: 1.2em; }
        input[type="number"] {
            padding: 10px; font-size: 1.1em; border: none; border-radius: 8px;
            background: rgba(255, 255, 255, 0.9); color: #333; width: 100px; text-align: center;
        }
        button {
            padding: 12px 24px; font-size: 1.1em; font-weight: bold; border: none; border-radius: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52); color: white; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        button:disabled { background: #aaa; cursor: not-allowed; transform: none; box-shadow: none; }
        
        /* Spezifische Button-Farben */
        .btn-generate { background: linear-gradient(45deg, #4ecdc4, #36a2eb); }
        .btn-action { background: linear-gradient(45deg, #ff9a44, #ff6b6b); }
        .btn-reset { background: linear-gradient(45deg, #999, #666); }

        .step-controls { margin: 20px auto; display: none; max-width: 400px; }
        .step-controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .step-controls button { margin: 0; background: linear-gradient(45deg, #4ecdc4, #36a2eb); width: 100%; }
        
        .table-container { background: rgba(0,0,0,0.6); padding: 20px; border-radius: 15px; overflow-x: auto; margin: 20px 0; display: none; position: relative; }
        table { width: 100%; border-collapse: collapse; font-size: 1.2em; position: relative; }
        th, td { border: 2px solid #fff; padding: 12px; text-align: center; font-weight: bold; position: relative; }
        th { background: linear-gradient(45deg, #667eea, #764ba2); font-size: 1.3em; }
        
        .explanation, .result { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin: 20px 0; display: none; }
        .result { text-align: center; font-size: 1.2em; border: 1px solid rgba(255, 255, 255, 0.2); }
        h3 { margin-top: 0; }
        
        .formula { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin: 10px 0; font-family: 'Courier New', monospace; font-size: 1.05em; border-left: 4px solid #ffd700; line-height: 1.6; }
        .step-info { background: rgba(255,255,255,0.1); padding: 10px 15px; border-radius: 10px; margin-bottom: 15px; text-align: center; font-weight: bold; }
        
        .math { font-family: 'Times New Roman', serif; font-size: 1.1em; }
        .math sup, .math sub { font-size: 0.7em; vertical-align: baseline; position: relative; }
        .math sup { bottom: 0.5em; }
        .math sub { top: 0.3em; }
        
        .math-block { display: block; text-align: center; margin: 15px 0; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .math-inline { display: inline-block; padding: 2px 5px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        
        .verification { margin: 15px 0; padding: 10px; border-radius: 8px; font-weight: bold; }
        .verification.success { background: rgba(0, 255, 0, 0.2); border: 1px solid rgba(0, 255, 0, 0.4); color: #adff2f; }
        .verification.error { background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.4); color: #ff4444; }
        
        .explanation-section { margin: 20px 0; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; border-left: 4px solid #4ecdc4; }
        .explanation-title { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: #ffffff; }
        
        .hidden { display: none; }
        
        /* Stile f√ºr Pfeil-Animationen (unver√§ndert) */
        .highlight-source { background: rgba(255, 100, 100, 0.4) !important; box-shadow: 0 0 10px rgba(255, 100, 100, 0.6); }
        .highlight-target { background: rgba(100, 255, 100, 0.4) !important; box-shadow: 0 0 10px rgba(100, 255, 100, 0.6); }
        .current-row { background: rgba(255,215,0,0.3) !important; }
        .xy-changed { background: rgba(0,255,0,0.2) !important; }
        .row-0 { background: rgba(255,255,255,0.1); }
        .row-1 { background: rgba(255,255,255,0.05); }

        #encryption-steps, #decryption-steps {
            font-family: 'Courier New', monospace;
            text-align: left;
            padding: 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            white-space: pre-wrap;
            line-height: 1.5;
            font-size: 1.1em;
        }

    </style>
</head>
<body>
<div class="container">
    <h1>üîë Interaktives RSA-Tool</h1>

    <h2>Schritt 1: Schl√ºsselgenerierung</h2>
    <div class="section">
        <div class="explanation-section">
            <div class="explanation-title">Primzahlen w√§hlen</div>
            W√§hle zwei (f√ºr dieses Beispiel kleine) Primzahlen <i>p</i> und <i>q</i>.
        </div>
        <div class="input-row">
            <div class="input-group">
                <label for="primeP">p =</label>
                <input type="number" id="primeP" value="7" min="2" />
            </div>
            <div class="input-group">
                <label for="primeQ">q =</label>
                <input type="number" id="primeQ" value="13" min="2" />
            </div>
        </div>
        <div class="button-container">
            <button onclick="loadPrimesExample()">üìù Beispielwerte (7, 13)</button>
            <button class="btn-generate" onclick="calculateNAndPhi()">‚û°Ô∏è n und œÜ(n) berechnen</button>
        </div>

        <div id="nPhiSection" class="hidden">
            <hr style="margin: 25px 0; border-color: rgba(255,255,255,0.3);">
            <div class="output-row">
                 <div class="output-group">
                    <label>RSA-Modul n = p ¬∑ q =</label>
                    <span id="nValue" class="output-value"></span>
                </div>
                 <div class="output-group">
                    <label>œÜ(n) = (p-1)¬∑(q-1) =</label>
                    <span id="phiValue" class="output-value"></span>
                </div>
            </div>
            
            <div class="explanation-section" style="margin-top: 20px;">
                <div class="explanation-title">√ñffentlichen Exponenten 'e' w√§hlen</div>
                W√§hle eine Zahl <i>e</i>, f√ºr die gilt: 1 &lt; e &lt; œÜ(n) und ggT(e, œÜ(n)) = 1 (<i>e</i> muss teilerfremd zu œÜ(n) sein).
            </div>
             <div class="input-row">
                <div class="input-group">
                    <label for="valueE">e =</label>
                    <input type="number" id="valueE" value="5" min="2" />
                </div>
            </div>
            <div class="button-container">
                 <button onclick="suggestE()">üí° 'e' vorschlagen</button>
                 <button class="btn-generate" onclick="setE()">‚û°Ô∏è Privaten Schl√ºssel 'd' berechnen</button>
            </div>
            <div id="eSuggestions" style="text-align:center; margin-top:15px;"></div>
        </div>
        
        <div id="keysSection" class="hidden">
             <hr style="margin: 25px 0; border-color: rgba(255,255,255,0.3);">
             <div class="explanation-section">
                <div class="explanation-title">Schl√ºsselpaare</div>
                <div class="output-row" style="justify-content: space-around;">
                    <div class="output-group">
                        <label>√ñffentlicher Schl√ºssel (n, e):</label>
                        <span id="publicKey" class="output-value"></span>
                    </div>
                    <div class="output-group">
                        <label>Privater Schl√ºssel (n, d):</label>
                        <span id="privateKey" class="output-value"></span>
                    </div>
                </div>
             </div>
        </div>
    </div>

    <div id="eeaWrapper" class="hidden">
        <h2>Schritt 2: Privaten Schl√ºssel 'd' berechnen (Erw. Euklidischer Algorithmus)</h2>
        <div class="section">
             <div class="explanation-section">
                <div class="explanation-title">Ziel</div>
                Wir suchen das modulare Inverse von <i>e</i> modulo <i>œÜ(n)</i>. Das Ergebnis wird unser privater Schl√ºssel <i>d</i> sein.
                Die Gleichung lautet: <span class="math-inline math">d ¬∑ e ‚â° 1 (mod œÜ(n))</span>.
            </div>
            <div class="input-section">
                <div class="input-row">
                    <div class="input-group">
                        <label for="valueA">a (Modulus, œÜ(n)) =</label>
                        <input type="number" id="valueA" min="1" readonly/>
                    </div>
                    <div class="input-group">
                        <label for="valueB">b (Zahl, e) =</label>
                        <input type="number" id="valueB" min="0" readonly/>
                    </div>
                </div>
            </div>

            <div class="step-controls" id="stepControls">
                <div class="step-info" id="stepInfo"></div>
                <div class="step-controls-grid">
                    <button onclick="previousStep()">‚¨ÖÔ∏è Vorheriger Schritt</button>
                    <button onclick="nextStep()">‚û°Ô∏è N√§chster Schritt</button>
                    <button onclick="showAllSteps()">‚ö° Alle Schritte zeigen</button>
                </div>
            </div>

            <div class="table-container" id="tableContainer">
                <table id="algorithmTable">
                    <thead><tr><th>i</th><th>a</th><th>b</th><th>v</th><th>r</th><th>x</th><th>y</th></tr></thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="explanation" id="explanation">
                <h3>üìã Schritt-f√ºr-Schritt Erkl√§rung:</h3>
                <div id="stepExplanation"></div>
            </div>

            <div class="result" id="result">
                <h3>üéØ Ergebnis des Algorithmus:</h3>
                <div id="finalResult"></div>
            </div>
        </div>
    </div>
    
    <div id="cryptoWrapper" class="hidden">
        <h2>Schritt 3: Ver- und Entschl√ºsselung</h2>
        <div class="section">
            <div class="explanation-section">
                <div class="explanation-title">Verschl√ºsselung</div>
                Gib eine Nachricht (als Zahl M &lt; n) ein, die mit dem <strong>√∂ffentlichen Schl√ºssel (n, e)</strong> verschl√ºsselt werden soll.
                <div class="math-block math">C = M<sup>e</sup> mod n</div>
            </div>
            <div class="input-row">
                <div class="input-group">
                    <label for="message">Nachricht M =</label>
                    <input type="number" id="message" value="9" min="0">
                </div>
                 <button class="btn-action" id="encryptBtn" onclick="encrypt()">Verschl√ºsseln</button>
            </div>
            <div id="encryptionResult" class="hidden" style="margin-top:20px;">
                <div class="output-row">
                     <div class="output-group">
                        <label>Chiffretext C =</label>
                        <span id="ciphertext" class="output-value"></span>
                    </div>
                </div>
                <div class="explanation-section">
                    <div class="explanation-title">Rechenweg (Modulare Exponentiation):</div>
                    <div id="encryption-steps"></div>
                </div>
            </div>
            
            <hr style="margin: 25px 0; border-color: rgba(255,255,255,0.3);">
            
            <div class="explanation-section">
                 <div class="explanation-title">Entschl√ºsselung</div>
                Nimm den Chiffretext C und entschl√ºssele ihn mit dem <strong>privaten Schl√ºssel (n, d)</strong>.
                <div class="math-block math">M = C<sup>d</sup> mod n</div>
            </div>
             <div class="input-row">
                <div class="input-group">
                    <label for="ciphertextInput">Chiffretext C =</label>
                    <input type="number" id="ciphertextInput" min="0">
                </div>
                 <button class="btn-action" id="decryptBtn" onclick="decrypt()">Entschl√ºsseln</button>
            </div>
            <div id="decryptionResult" class="hidden" style="margin-top:20px;">
                <div class="output-row">
                     <div class="output-group">
                        <label>Entschl√ºsselte Nachricht M' =</label>
                        <span id="decryptedMessage" class="output-value"></span>
                    </div>
                </div>
                 <div class="explanation-section">
                    <div class="explanation-title">Rechenweg (Modulare Exponentiation):</div>
                    <div id="decryption-steps"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="button-container">
        <button class="btn-reset" onclick="fullReset()">üîÑ Komplett zur√ºcksetzen</button>
    </div>

</div>

<script>
    // Globale Variablen f√ºr den RSA-Prozess
    let p, q, n, phi, e, d;

    // === NEUE FUNKTIONEN f√ºr RSA-Schl√ºsselgenerierung ===

    function isPrime(num) {
        if (num <= 1) return false; if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i = i + 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

    function loadPrimesExample() {
        document.getElementById('primeP').value = 7;
        document.getElementById('primeQ').value = 13;
        document.getElementById('valueE').value = 5;
        document.getElementById('message').value = 9;
    }

    function calculateNAndPhi() {
        p = parseInt(document.getElementById('primeP').value);
        q = parseInt(document.getElementById('primeQ').value);

        if (!isPrime(p) || !isPrime(q)) { alert("Fehler: Bitte geben Sie zwei g√ºltige Primzahlen f√ºr p und q ein."); return; }
        if (p === q) { alert("Fehler: p und q d√ºrfen nicht dieselbe Primzahl sein."); return; }

        n = p * q;
        phi = (p - 1) * (q - 1);

        document.getElementById('nValue').innerText = n;
        document.getElementById('phiValue').innerText = phi;
        document.getElementById('nPhiSection').classList.remove('hidden');
        document.getElementById('valueE').max = phi - 1;
    }
    
    function suggestE() {
        if (!phi) return;
        let suggestions = [];
        for (let i = 3; i < phi && suggestions.length < 10; i += 2) {
            if (gcd(i, phi) === 1) { suggestions.push(i); }
        }
        const suggestionsDiv = document.getElementById('eSuggestions');
        suggestionsDiv.innerHTML = 'M√∂gliche Werte f√ºr <i>e</i>: ' + suggestions.join(', ');
        if (suggestions.length > 0) { document.getElementById('valueE').value = suggestions[0]; }
    }

    function setE() {
        e = parseInt(document.getElementById('valueE').value);
        if (!e || e <= 1 || e >= phi) { alert(`Fehler: 'e' muss gr√∂√üer als 1 und kleiner als œÜ(n) (${phi}) sein.`); return; }
        if (gcd(e, phi) !== 1) { alert(`Fehler: 'e' (${e}) ist nicht teilerfremd zu œÜ(n) (${phi}). Der ggT ist ${gcd(e, phi)}.`); return; }
        
        document.getElementById('valueA').value = phi;
        document.getElementById('valueB').value = e;
        document.getElementById('eeaWrapper').classList.remove('hidden');
        startAlgorithm();
    }

    // === Logik f√ºr Ver- und Entschl√ºsselung (mit neuer Erkl√§rung) ===

    function modularExponentiation(base, exp, mod) {
        if (mod === 1) return { result: 0, steps: "Modul ist 1, Ergebnis ist 0." };
        let result = 1;
        let steps = `Berechnung: ${base}^${exp} mod ${mod}\n`;
        steps += `-----------------------------------\n`;
        base = base % mod;
        
        let binaryExp = exp.toString(2);
        steps += `Exponent ${exp} in bin√§r: ${binaryExp}\n\n`;

        for (let i = 0; i < binaryExp.length; i++) {
            let bit = parseInt(binaryExp[i]);
            steps += `Bit ${i+1} (von links): ${bit}\n`;
            
            let oldResult = result;
            result = (result * result) % mod;
            steps += `  1. Quadrieren: ${oldResult}^2 = ${oldResult*oldResult} ‚â° ${result} (mod ${mod})\n`;

            if (bit === 1) {
                 oldResult = result;
                 result = (result * base) % mod;
                 steps += `  2. Da Bit=1, multiplizieren: ${oldResult} * ${base} = ${oldResult*base} ‚â° ${result} (mod ${mod})\n`;
            } else {
                 steps += `  2. Da Bit=0, keine Multiplikation.\n`;
            }
            steps += `  -> Zwischenergebnis: ${result}\n\n`;
        }
        steps += `-----------------------------------\n`;
        steps += `Endergebnis: ${result}`;
        return { result, steps };
    }
    
    // --------------------------------------------------------------------
    // NEUER TEIL: Erkl√§rungstext als separate Funktion/Variable
    // --------------------------------------------------------------------
    function getTheoryExplanation() {
        return `
            <div class="explanation-title" style="color: #4ecdc4; margin-bottom: 5px;">Das "Square-and-Multiply"-Verfahren</div>
            <p style="margin: 0; line-height: 1.6;">
                Dieser schnelle Algorithmus nutzt die <strong>bin√§re Darstellung des Exponenten</strong>, um die Berechnung extrem zu beschleunigen.
            </p>
            <ul style="margin: 10px 0; padding-left: 20px; line-height: 1.6;">
                <li>
                    <strong>Quadrieren (Square):</strong> In jedem Schritt wird das bisherige Ergebnis quadriert. Dies erzeugt effizient die Folge der Zweierpotenzen (z.B. M, M¬≤, M‚Å¥, M‚Å∏, ...), was dem Durchlaufen der Bits des Exponenten von links nach rechts entspricht.
                </li>
                <li>
                    <strong>Multiplizieren (Multiply):</strong> Nur wenn das aktuelle Bit eine <strong>1</strong> ist, wird das Ergebnis zus√§tzlich mit der urspr√ºnglichen Basis (M oder C) multipliziert. Eine '1' im Bin√§rwert bedeutet, dass die an dieser Stelle erzeugte Potenz f√ºr das Endergebnis ben√∂tigt wird (z.B. 5 = 4 + 1, bin√§r '101' ‚Üí wir brauchen die Potenzen f√ºr 4 und 1).
                </li>
            </ul>
        `;
    }


    function encrypt() {
        const messageVal = parseInt(document.getElementById('message').value);
        if (isNaN(messageVal) || messageVal >= n) { alert(`Die Nachricht M (${messageVal}) muss eine Zahl und kleiner als n (${n}) sein.`); return; }
        
        // Theorie-Erkl√§rung einf√ºgen
        const theoryDiv = document.getElementById('encryptionResult').querySelector('.explanation-section');
        theoryDiv.innerHTML = getTheoryExplanation(); // F√ºgt die Erkl√§rung hinzu

        let context = `Formel: C = M^e mod n\n`;
        context += `Variablen: M=${messageVal}, e=${e}, n=${n}\n\n`;

        const { result: C, steps } = modularExponentiation(messageVal, e, n);

        document.getElementById('ciphertext').innerText = C;
        document.getElementById('ciphertextInput').value = C;
        
        // Rechenweg in ein separates Element innerhalb der Erkl√§rung einf√ºgen
        const stepsDiv = document.createElement('div');
        stepsDiv.id = 'encryption-steps';
        stepsDiv.innerText = context + steps;
        theoryDiv.appendChild(stepsDiv);

        document.getElementById('encryptionResult').classList.remove('hidden');
        document.getElementById('decryptionResult').classList.add('hidden');
    }

    function decrypt() {
        const ciphertextVal = parseInt(document.getElementById('ciphertextInput').value);
        if (isNaN(ciphertextVal) || ciphertextVal >= n) { alert(`Der Chiffretext C (${ciphertextVal}) muss eine Zahl und kleiner als n (${n}) sein.`); return; }
        
        // Theorie-Erkl√§rung einf√ºgen
        const theoryDiv = document.getElementById('decryptionResult').querySelector('.explanation-section');
        theoryDiv.innerHTML = getTheoryExplanation(); // F√ºgt die Erkl√§rung hinzu

        let context = `Formel: M = C^d mod n\n`;
        context += `Variablen: C=${ciphertextVal}, d=${d}, n=${n}\n\n`;

        const { result: M, steps } = modularExponentiation(ciphertextVal, d, n);

        document.getElementById('decryptedMessage').innerText = M;

        // Rechenweg in ein separates Element innerhalb der Erkl√§rung einf√ºgen
        const stepsDiv = document.createElement('div');
        stepsDiv.id = 'decryption-steps';
        stepsDiv.innerText = context + steps;
        theoryDiv.appendChild(stepsDiv);
        
        document.getElementById('decryptionResult').classList.remove('hidden');
    }
    
    // ... Rest des JavaScript-Codes (fullReset, EEA-Funktionen, etc.) bleibt unver√§ndert ...
    // ... (Hier folgt der unver√§nderte Rest des Skripts) ...
    function fullReset() {
        p = q = n = phi = e = d = undefined;
        document.getElementById('nPhiSection').classList.add('hidden');
        document.getElementById('keysSection').classList.add('hidden');
        document.getElementById('eeaWrapper').classList.add('hidden');
        document.getElementById('cryptoWrapper').classList.add('hidden');
        document.getElementById('encryptionResult').classList.add('hidden');
        document.getElementById('decryptionResult').classList.add('hidden');
        document.getElementById('primeP').value = '7';
        document.getElementById('primeQ').value = '13';
        document.getElementById('valueE').value = '5';
        document.getElementById('eSuggestions').innerHTML = '';
        document.getElementById('message').value = '9';
        document.getElementById('ciphertextInput').value = '';
        resetEEA();
    }
    function resetEEA() {
        document.getElementById('stepControls').style.display = 'none';
        document.getElementById('tableContainer').style.display = 'none';
        document.getElementById('explanation').style.display = 'none';
        document.getElementById('result').style.display = 'none';
        document.getElementById('stepInfo').style.display = 'none';
        allSteps = []; currentStepIndex = 0;
        clearAnimations();
    }
    let currentA, currentB, originalA, originalB;
    let allSteps = [];
    let currentStepIndex = 0;
    function startAlgorithm() {
        currentA = parseInt(document.getElementById('valueA').value);
        currentB = parseInt(document.getElementById('valueB').value);
        originalA = currentA; originalB = currentB;
        if (!Number.isFinite(currentA) || !Number.isFinite(currentB) || currentA <= 0 || currentB < 0) { alert('Bitte geben Sie g√ºltige Zahlen ein.'); return; }
        calculateAllSteps();
        currentStepIndex = 0;
        showCurrentStep();
        document.getElementById('stepControls').style.display = 'block';
        document.getElementById('tableContainer').style.display = 'block';
        document.getElementById('explanation').style.display = 'block';
        document.getElementById('stepInfo').style.display = 'block';
    }
    function calculateAllSteps() {
        allSteps = []; let steps = [];
        let tempA = currentA, tempB = currentB;
        let i = 1;
        while (tempB !== 0) {
            const v_div = Math.floor(tempA / tempB);
            const r = tempA % tempB;
            steps.push({ i, a: tempA, b: tempB, v: v_div, r, x: null, y: null });
            allSteps.push({
                type: 'euclidean', tableData: JSON.parse(JSON.stringify(steps)), currentRow: steps.length - 1,
                explanation: `Zeile ${i}: ${tempA} √∑ ${tempB} = ${v_div} Rest ${r}`,
                stepNumber: allSteps.length + 1
            });
            tempA = tempB; tempB = r; i++;
        }
        steps.push({ i, a: tempA, b: 0, v: null, r: null, x: null, y: null });
        allSteps.push({
            type: 'euclidean_end', tableData: JSON.parse(JSON.stringify(steps)), currentRow: steps.length - 1,
            explanation: `Algorithmus beendet: Rest = 0<br>Der ggT ist die letzte Zahl in Spalte 'a': **${tempA}**.`,
            stepNumber: allSteps.length + 1
        });
        const lastIdx = steps.length - 2;
        steps[lastIdx].x = 0; steps[lastIdx].y = 1;
        allSteps.push({
            type: 'xy_init', tableData: JSON.parse(JSON.stringify(steps)), currentRow: lastIdx,
            explanation: `üîç Phase 2 startet.<br>Wir setzen die Startwerte f√ºr die vorletzte Zeile (i=${steps[lastIdx].i}): x = 0 und y = 1.`,
            stepNumber: allSteps.length + 1
        });
        for (let j = lastIdx - 1; j >= 0; j--) {
            const v_calc = steps[j].v;
            const xNext = steps[j + 1].x; const yNext = steps[j + 1].y;
            const y_calc = xNext - v_calc * yNext;
            steps[j].x = yNext;
            allSteps.push({
                type: 'xy_calc_x', tableData: JSON.parse(JSON.stringify(steps)), currentRow: j,
                explanation: `Neuer x-Wert f√ºr Zeile ${j + 1}: <span class="math-inline math">x<sub>i</sub> = y<sub>i+1</sub></span>. Also **x = ${yNext}**.`,
                stepNumber: allSteps.length + 1
            });
            steps[j].y = y_calc;
            allSteps.push({
                type: 'xy_calc_y', tableData: JSON.parse(JSON.stringify(steps)), currentRow: j,
                explanation: `Neuer y-Wert f√ºr Zeile ${j + 1}: <span class="math-inline math">y<sub>i</sub> = x<sub>i+1</sub> - v<sub>i</sub> &middot; y<sub>i+1</sub></span>. Also **y = ${xNext} - ${v_calc} ¬∑ ${yNext} = ${y_calc}**.`,
                stepNumber: allSteps.length + 1
            });
        }
    }
    function showCurrentStep() {
        if (currentStepIndex >= allSteps.length) return;
        clearAnimations();
        const step = allSteps[currentStepIndex];
        const tbody = document.getElementById('tableBody');
        tbody.innerHTML = '';
        const phaseText =
            step.type.startsWith('euclidean') ? 'üî¢ Phase 1: Euklidischer Algorithmus'
            : step.type === 'xy_init' ? 'üîç Phase 2: x,y Startwerte'
            : 'üîç Phase 2: R√ºckw√§rtsberechnung';
        document.getElementById('stepInfo').innerHTML = `Schritt ${step.stepNumber} von ${allSteps.length}: ${phaseText}`;
        document.getElementById('stepExplanation').innerHTML = `<div class="formula">${step.explanation}</div>`;
        for (let i = 0; i < step.tableData.length; i++) {
            const row = tbody.insertRow();
            const d = step.tableData[i];
            row.insertCell().textContent = d.i; row.insertCell().textContent = d.a;
            row.insertCell().textContent = d.b; row.insertCell().textContent = d.v ?? '';
            row.insertCell().textContent = d.r ?? ''; row.insertCell().textContent = d.x ?? '';
            row.insertCell().textContent = d.y ?? '';
            row.className = (i === step.currentRow) ? (step.type.startsWith('xy') ? 'xy-changed' : 'current-row') : (i % 2 === 0 ? 'row-0' : 'row-1');
        }
        if (step.type === 'euclidean' && step.currentRow > 0) { showDataMigration(step.currentRow - 1, step.currentRow); } 
        else if (step.type === 'xy_calc_x') { showXYCalculation_X(step.currentRow, step.currentRow + 1); } 
        else if (step.type === 'xy_calc_y') { showXYCalculation_Y(step.currentRow, step.currentRow + 1); }
        if (currentStepIndex === allSteps.length - 1) showFinalResult();
    }
    function showXYCalculation_Y(currentRow, nextRow) {
        const table = document.getElementById('algorithmTable'); const rows = table.querySelectorAll('tbody tr');
        if (currentRow >= 0 && currentRow < rows.length && nextRow < rows.length) {
            const fromXCell = rows[nextRow].cells[5]; const fromVCell = rows[currentRow].cells[3]; // Index 3 ist jetzt 'v'
            const fromYCell = rows[nextRow].cells[6]; const toYCell = rows[currentRow].cells[6];
            fromXCell.classList.add('highlight-source'); fromVCell.classList.add('highlight-source');
            fromYCell.classList.add('highlight-source'); toYCell.classList.add('highlight-target');
            addArrow(fromXCell, toYCell, `x_{i+1}`); addArrow(fromVCell, toYCell, `v_{i}`); addArrow(fromYCell, toYCell, `y_{i+1}`);
        }
    }
    function showFinalResult() {
        const finalStep = allSteps[allSteps.length - 1];
        const finalData = finalStep.tableData;
        const gcdVal = finalData[finalData.length - 1].a;
        const x_final = finalData[0].x; const y_final = finalData[0].y;
        const mod = (t, m) => ((t % m) + m) % m;
        let resultText = `
            <div class="explanation-section">
                <div class="explanation-title">Bezout-Gleichung: ggT(a,b) = a¬∑x + b¬∑y</div>
                <div class="math-block math">${originalA} ¬∑ (${x_final}) + ${originalB} ¬∑ (${y_final}) = ${originalA * x_final + originalB * y_final}</div>
                <div>Das Ergebnis ist wie erwartet der ggT(${originalA}, ${originalB}) = <strong>${gcdVal}</strong>.</div>
            </div>`;
        if (gcdVal === 1) {
            const inverse = mod(y_final, originalA);
            d = inverse; // Privaten Schl√ºssel 'd' setzen
            resultText += `
                <div class="explanation-section">
                    <div class="explanation-title">Modulares Inverses 'd'</div>
                    <div>Aus der Gleichung ergibt sich der Koeffizient <span class="math-inline math">y = ${y_final}</span>. Dieser ist das Inverse von b (e) modulo a (œÜ(n)).</div>
                    ${y_final < 0 ? `<div>Da y negativ ist, rechnen wir <span class="math-inline math">y mod a</span>:</div>
                    <div class="math-block math">${y_final} mod ${originalA} = ${inverse}</div>` : ''}
                    <div class="verification success">Der private Schl√ºssel d ist: <strong>${d}</strong></div>
                </div>`;
            document.getElementById('publicKey').innerText = `(${n}, ${e})`;
            document.getElementById('privateKey').innerText = `(${n}, ${d})`;
            document.getElementById('keysSection').classList.remove('hidden');
            document.getElementById('cryptoWrapper').classList.remove('hidden');
        } else {
            resultText += `<div class="verification error">Fehler: Der ggT ist nicht 1. Es kann kein modularer Inverser und damit kein Schl√ºssel 'd' gefunden werden. Bitte w√§hle ein anderes 'e'.</div>`;
        }
        document.getElementById('finalResult').innerHTML = resultText;
        document.getElementById('result').style.display = 'block';
    }
    function clearAnimations() { const arrows = document.querySelectorAll('#tableContainer svg'); arrows.forEach(a => a.remove()); document.querySelectorAll('td').forEach(c => c.classList.remove('highlight-source', 'highlight-target')); }
    function showDataMigration(fromRow, toRow) { const rows = document.querySelectorAll('#algorithmTable tbody tr'); if (fromRow >= 0 && fromRow < rows.length && toRow < rows.length) { const fromBCell = rows[fromRow].cells[2]; const toACell = rows[toRow].cells[1]; const fromRCell = rows[fromRow].cells[4]; const toBCell = rows[toRow].cells[2]; fromBCell.classList.add('highlight-source'); toACell.classList.add('highlight-target'); addArrow(fromBCell, toACell, 'b‚Üía'); addArrow(fromRCell, toBCell, 'r‚Üíb'); } }
    function showXYCalculation_X(currentRow, nextRow) { const rows = document.querySelectorAll('#algorithmTable tbody tr'); if (currentRow >= 0 && currentRow < rows.length && nextRow < rows.length) { const fromYCell = rows[nextRow].cells[6]; const toXCell = rows[currentRow].cells[5]; fromYCell.classList.add('highlight-source'); toXCell.classList.add('highlight-target'); addArrow(fromYCell, toXCell, `x = y_{i+1}`); } }
    function addArrow(fromCell, toCell, label) { const fromRect = fromCell.getBoundingClientRect(); const toRect = toCell.getBoundingClientRect(); const containerRect = document.getElementById('tableContainer').getBoundingClientRect(); const fromX = fromRect.left - containerRect.left + fromRect.width / 2; const fromY = fromRect.top - containerRect.top + fromRect.height / 2; const toX = toRect.left - containerRect.left + toRect.width / 2; const toY = toRect.top - containerRect.top + toRect.height / 2; const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); svg.style.cssText = 'position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:10;'; const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', fromX); line.setAttribute('y1', fromY); line.setAttribute('x2', toX); line.setAttribute('y2', toY); line.setAttribute('stroke', '#ffd700'); line.setAttribute('stroke-width', '3'); const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', `arrowhead-${Math.random()}`); marker.setAttribute('markerWidth', '10'); marker.setAttribute('markerHeight', '7'); marker.setAttribute('refX', '9'); marker.setAttribute('refY', '3.5'); marker.setAttribute('orient', 'auto'); const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); polygon.setAttribute('points', '0 0, 10 3.5, 0 7'); polygon.setAttribute('fill', '#ffd700'); marker.appendChild(polygon); defs.appendChild(marker); svg.appendChild(defs); line.setAttribute('marker-end', `url(#${marker.id})`); svg.appendChild(line); const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); text.setAttribute('x', (fromX + toX) / 2); text.setAttribute('y', (fromY + toY) / 2 - 8); text.setAttribute('text-anchor', 'middle'); text.setAttribute('fill', '#ffd700'); text.setAttribute('font-size', '11'); text.setAttribute('font-weight', 'bold'); text.style.filter = 'drop-shadow(1px 1px 2px rgba(0,0,0,0.8))'; text.textContent = label; svg.appendChild(text); document.getElementById('tableContainer').appendChild(svg); }
    function nextStep() { if (currentStepIndex < allSteps.length - 1) { currentStepIndex++; showCurrentStep(); } }
    function previousStep() { if (currentStepIndex > 0) { currentStepIndex--; showCurrentStep(); document.getElementById('result').style.display = 'none'; } }
    function showAllSteps() { document.getElementById('stepControls').style.pointerEvents = 'none'; for (let i = currentStepIndex; i < allSteps.length; i++) { setTimeout(() => { currentStepIndex = i; showCurrentStep(); if(i === allSteps.length-1) document.getElementById('stepControls').style.pointerEvents = 'auto'; }, (i - currentStepIndex) * 700); } }

    // Initialen Beispielwert laden
    loadPrimesExample();
</script>
</body>
</html>
